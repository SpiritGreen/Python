'''
В случае, когда необходимо выполнить поиск в уже упорядоченном списке, можно использовать двоичный поиск, алгоритм которого сводится к такой последовательности:

1. Для заданного промежутка в массиве (изначально он равен всему массиву, то есть начало — 0, конец — длина массива) найти позиции элемента по середине как «Средний элемент = (начало + конец) / 2». Деление должно быть целочисленным.
2. Сравить элемент по вычисленному индексу с ключом. Если они равны, то вернуть текущий индекс
3. Если элементы не равны и ключ меньше элемента по середине, то выставить «конец = середина - 1» и рекурсивно вызвать поиск
4. Если элементы не равны и ключ больше элемента по середине, то выставить «начало = середина + 1» и рекурсивно вызвать поиск

Для корректной работы также необходимо в самом начале функции проверить, что индекс начала больше индекса конца. Если это не так, то это будет значить, что элемент не может быть найден. Такая ситуация возникает и в процессе рекурсивного вызова. При этом индекс начала интрепретируется как индекс, куда нужно добавить ключ, чтобы последовательность была верной. Чтобы её отличать от ситуации когда элемент всё-таки найден этот индекс берут с отрицательным знаком и вычитаются единицу. Таким образом можно, результат работы алгоритма должен быть:

arr = [1, 3, 5]
print(binary_search(arr, 1, 0, len(arr) - 1) == 0)
print(binary_search(arr, 3, 0, len(arr) - 1) == 1)
print(binary_search(arr, 5, 0, len(arr) - 1) == 2)
print(binary_search(arr, 0, 0, len(arr) - 1) == -0 - 1)
print(binary_search(arr, 2, 0, len(arr) - 1) == -1 - 1)
print(binary_search(arr, 4, 0, len(arr) - 1) == -2 - 1)
print(binary_search(arr, 6, 0, len(arr) - 1) == -3 - 1)
Где процедура binary_search имеет следуещее описание:
def binary_search(x, key, start, end)
x — упорядоченный список элементов key — искомый элемент start — индекс начала end — индекс конца Процедура возвращает индекс элемента в списке или индекс взятый с отрицательным знаком - 1 позиции, где этот элемент должен был бы находиться
'''

def binary_search(arr, key, start, end):
  if start > end:
    return -start - 1
  middle = (start + end) // 2
  if arr[middle] == key:
    return middle
  elif arr[middle] > key:
    end = middle - 1
    return binary_search(arr, key, start, end)
  else:
    start = middle + 1
    return binary_search(arr, key, start, end)

	
print(binary_search([1], 0, 0, 0))
print(binary_search([1], 2, 0, 0))
print(binary_search([1, 4, 5, 9, 12, 18, 29, 30], 0, 0, 7))
print(binary_search([1, 4, 5, 9, 12, 18, 29, 30], 8, 0, 7))